//! Application configuration handling.

use std::{collections::HashMap, fs, path::PathBuf};

use anyhow::{Context, Result};
use config::{Config, Environment, File};
use serde::Deserialize;

/// Default config file name searched relative to the user config directory.
pub const CONFIG_FILE: &str = "18tui.toml";

/// Environment variable prefix (e.g. `TUI18__CACHE_ROOT`).
pub const ENV_PREFIX: &str = "TUI18";

/// Runtime configuration derived from files/environment.
#[derive(Debug, Clone, Deserialize)]
pub struct AppConfig {
    /// Path to the cache directory where the engine repo lives.
    #[serde(default = "default_cache_root")]
    pub cache_root: PathBuf,
    /// Engine repository URL.
    #[serde(default = "default_repo_url")]
    pub repo_url: String,
    /// Git branch to follow.
    #[serde(default = "default_repo_branch")]
    pub repo_branch: String,
}

impl AppConfig {
    /// Load configuration by merging the default config file and environment variables.
    pub fn load() -> Result<Self> {
        let mut builder = Config::builder();
        builder = builder.add_source(File::from(default_config_path()).required(false));
        builder = builder.add_source(Environment::with_prefix(ENV_PREFIX).separator("__"));
        let config = builder
            .build()
            .context("failed to build configuration sources")?;
        config
            .try_deserialize::<AppConfig>()
            .context("failed to deserialize configuration")
    }

    /// Returns a flat map of settings, useful for diagnostics.
    pub fn as_map(&self) -> HashMap<&'static str, String> {
        HashMap::from([
            ("cache_root", self.cache_root.to_string_lossy().into_owned()),
            ("repo_url", self.repo_url.clone()),
            ("repo_branch", self.repo_branch.clone()),
        ])
    }
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            cache_root: default_cache_root(),
            repo_url: default_repo_url(),
            repo_branch: default_repo_branch(),
        }
    }
}

fn default_config_path() -> PathBuf {
    dirs::config_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("18tui")
        .join(CONFIG_FILE)
}

fn default_cache_root() -> PathBuf {
    dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("18tui")
}

fn default_repo_url() -> String {
    "https://github.com/tobymao/18xx.git".to_string()
}

fn default_repo_branch() -> String {
    "master".to_string()
}

/// Persist a default configuration file if none exists.
pub fn ensure_default_config() -> Result<()> {
    let path = default_config_path();
    if path.exists() {
        return Ok(());
    }

    let parent = path
        .parent()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("."));
    fs::create_dir_all(&parent).context("failed to create config directory")?;

    let defaults = AppConfig::load().unwrap_or_else(|_| AppConfig::default());

    let body = format!(
        "# Default configuration generated by tui18\ncache_root = \"{}\"\nrepo_url = \"{}\"\nrepo_branch = \"{}\"\n",
        defaults.cache_root.display(),
        defaults.repo_url,
        defaults.repo_branch
    );
    fs::write(&path, body).with_context(|| format!("failed to write {}", path.display()))
}
